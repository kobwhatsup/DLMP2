# 系统架构文档

## 1. 整体架构概览

### 1.1 架构图
```
┌─────────────────────────────────────────────────────────────────┐
│                        接入层                                    │
├─────────────────────────────────────────────────────────────────┤
│  CDN  │  负载均衡器(Nginx)  │  API网关(Spring Cloud Gateway)  │
└─────────────────────────────────────────────────────────────────┘
                                     │
┌─────────────────────────────────────────────────────────────────┐
│                        应用层                                    │
├─────────────────────────────────────────────────────────────────┤
│ 用户服务 │ 案件服务 │ 分案服务 │ 调解服务 │ 诉讼服务 │ 结算服务 │
└─────────────────────────────────────────────────────────────────┘
                                     │
┌─────────────────────────────────────────────────────────────────┐
│                        数据层                                    │
├─────────────────────────────────────────────────────────────────┤
│  MySQL集群  │  Redis集群  │  对象存储  │  Elasticsearch集群  │
└─────────────────────────────────────────────────────────────────┘
                                     │
┌─────────────────────────────────────────────────────────────────┐
│                      基础设施层                                  │
├─────────────────────────────────────────────────────────────────┤
│  Nacos  │  RocketMQ  │  监控  │  日志  │  链路追踪  │  安全  │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 架构原则
- **微服务架构**：按业务领域拆分服务，数据独立，松耦合
- **云原生设计**：支持容器化部署，弹性伸缩
- **高可用性**：多副本部署，故障自动恢复
- **数据一致性**：最终一致性，分布式事务支持
- **安全可靠**：多层防护，数据加密，访问控制

## 2. 微服务架构设计

### 2.1 服务拆分策略

#### 2.1.1 垂直拆分（按业务领域）
- **用户域**：用户管理、权限控制、认证授权
- **案件域**：案件管理、材料存储、状态流转
- **分案域**：规则配置、智能匹配、分配管理
- **调解域**：调解流程、文书管理、调解员管理
- **诉讼域**：诉讼跟踪、法院对接、执行管理
- **结算域**：费用计算、账单生成、支付管理
- **通知域**：消息推送、邮件发送、站内信

#### 2.1.2 水平拆分（按数据量）
- **案件数据**：按年份分表，支持历史数据归档
- **材料文件**：按案件ID哈希分布，负载均衡
- **操作日志**：按时间分表，定期清理

### 2.2 核心微服务详细设计

#### 2.2.1 用户管理服务 (user-service)
```yaml
服务职责:
  - 用户注册、登录、注销
  - 权限管理（RBAC）
  - JWT令牌管理
  - 用户信息维护

技术栈:
  - Spring Boot 3.2
  - Spring Security 6
  - JWT
  - MySQL

数据库表:
  - t_user: 用户基本信息
  - t_role: 角色信息
  - t_permission: 权限信息
  - t_user_role: 用户角色关联
  - t_role_permission: 角色权限关联

接口设计:
  - POST /api/user/register: 用户注册
  - POST /api/user/login: 用户登录
  - GET /api/user/profile: 获取用户信息
  - PUT /api/user/profile: 更新用户信息
  - GET /api/user/permissions: 获取用户权限
```

#### 2.2.2 案件管理服务 (case-service)
```yaml
服务职责:
  - 案件导入、查询、更新
  - 案件状态流转管理
  - 案件材料关联管理
  - 案件督办功能

技术栈:
  - Spring Boot 3.2
  - MyBatis-Plus
  - MySQL (分库分表)
  - Redis (缓存)

数据库表:
  - t_case: 案件基本信息
  - t_case_material: 案件材料信息
  - t_case_log: 案件操作日志
  - t_case_supervision: 案件督办记录

接口设计:
  - POST /api/case/import: 批量导入案件
  - GET /api/case/list: 查询案件列表
  - GET /api/case/{id}: 获取案件详情
  - PUT /api/case/{id}/status: 更新案件状态
  - POST /api/case/{id}/supervise: 案件督办
```

#### 2.2.3 智能分案服务 (assignment-service)
```yaml
服务职责:
  - 分案规则配置管理
  - 智能匹配算法实现
  - 分案结果记录
  - 重新分配处理

技术栈:
  - Spring Boot 3.2
  - Drools (规则引擎)
  - Redis (缓存规则)
  - RocketMQ (异步处理)

核心算法:
  - 地域匹配: 优先同城分配
  - 能力匹配: 根据案件复杂度匹配
  - 负载均衡: 考虑调解中心工作量
  - 法院资源: 考虑法院案件饱和度

接口设计:
  - POST /api/assignment/rules: 配置分案规则
  - POST /api/assignment/assign: 执行案件分配
  - GET /api/assignment/history: 查询分配历史
  - PUT /api/assignment/reassign: 重新分配
```

#### 2.2.4 调解管理服务 (mediation-service)
```yaml
服务职责:
  - 调解流程管理
  - 调解文书生成
  - 调解员管理
  - 调解进展跟踪

技术栈:
  - Spring Boot 3.2
  - Spring Data JPA
  - Apache POI (文档生成)
  - WebSocket (实时通信)

业务流程:
  - 接收案件 -> 分配调解员 -> 联系债务人 -> 调解进行 -> 结果确认

接口设计:
  - POST /api/mediation/accept: 接收调解案件
  - PUT /api/mediation/{id}/assign: 分配调解员
  - POST /api/mediation/{id}/progress: 更新调解进展
  - POST /api/mediation/{id}/agreement: 生成调解协议
```

#### 2.2.5 诉讼管理服务 (litigation-service)
```yaml
服务职责:
  - 诉讼材料准备
  - 立案进度跟踪
  - 庭审进展管理
  - 执行阶段跟踪

技术栈:
  - Spring Boot 3.2
  - Spring Data JPA
  - 第三方法院接口
  - 文书模板引擎

业务流程:
  - 材料准备 -> 预约立案 -> 立案成功 -> 庭审进行 -> 判决执行

接口设计:
  - POST /api/litigation/prepare: 准备诉讼材料
  - POST /api/litigation/filing: 提交立案申请
  - PUT /api/litigation/{id}/trial: 更新庭审进展
  - PUT /api/litigation/{id}/execution: 更新执行进展
```

#### 2.2.6 结算管理服务 (settlement-service)
```yaml
服务职责:
  - 费用计算规则管理
  - 结算数据统计
  - 结算凭证生成
  - 支付状态跟踪

技术栈:
  - Spring Boot 3.2
  - Spring Batch (批处理)
  - 报表生成组件
  - 支付接口对接

结算类型:
  - 调解坐席租赁费用
  - 分散诉讼服务费用
  - 成功收费模式

接口设计:
  - POST /api/settlement/calculate: 计算结算费用
  - GET /api/settlement/report: 生成结算报表
  - POST /api/settlement/confirm: 确认结算凭证
  - GET /api/settlement/payment: 查询支付状态
```

## 3. 数据架构设计

### 3.1 数据库设计

#### 3.1.1 分库分表策略
```yaml
垂直分库:
  - user_db: 用户相关表
  - case_db: 案件相关表
  - mediation_db: 调解相关表
  - litigation_db: 诉讼相关表
  - settlement_db: 结算相关表
  - log_db: 日志相关表

水平分表:
  - 案件表: 按年份分表 (t_case_2024, t_case_2025)
  - 材料表: 按案件ID哈希分16张表
  - 日志表: 按月份分表
```

#### 3.1.2 读写分离架构
```yaml
主库配置:
  - 节点数量: 1个Master节点
  - 职责: 处理所有写操作
  - 配置: 高性能SSD，充足内存

从库配置:
  - 节点数量: 3个Slave节点
  - 职责: 处理读操作，负载均衡
  - 配置: 可使用机械硬盘，降低成本

同步机制:
  - 主从复制: MySQL binlog复制
  - 延迟监控: 复制延迟控制在1秒内
  - 故障切换: 自动故障检测和切换
```

### 3.2 缓存架构设计

#### 3.2.1 多级缓存策略
```yaml
L1缓存 (本地缓存):
  - 技术: Caffeine
  - 用途: 热点数据，减少网络开销
  - 容量: 10000个条目
  - TTL: 30分钟

L2缓存 (分布式缓存):
  - 技术: Redis Cluster
  - 用途: 共享数据，会话存储
  - 容量: 根据需要动态扩展
  - TTL: 1-24小时

L3缓存 (数据库查询缓存):
  - 技术: MySQL Query Cache
  - 用途: SQL查询结果缓存
  - 配置: 适当开启，避免缓存失效开销
```

#### 3.2.2 缓存更新策略
```yaml
写策略:
  - Cache Aside: 应用程序管理缓存
  - 延迟双删: 写操作后延迟删除缓存
  - 消息通知: 通过MQ通知缓存更新

一致性保证:
  - 分布式锁: 防止缓存击穿
  - 版本控制: 乐观锁避免并发问题
  - 监控告警: 缓存命中率监控
```

### 3.3 存储架构设计

#### 3.3.1 分层存储策略
```yaml
热存储 (0-1年):
  - 介质: 高性能SSD + 内存缓存
  - 容量: 1PB
  - 响应: 毫秒级
  - 成本: 高

温存储 (1-3年):
  - 介质: 高容量机械硬盘
  - 容量: 2PB
  - 响应: 秒级
  - 成本: 中等

冷存储 (3年以上):
  - 介质: 云归档存储
  - 容量: 7PB+
  - 响应: 分钟级
  - 成本: 低
```

#### 3.3.2 对象存储设计
```yaml
存储桶设计:
  - case-materials-hot/: 热数据存储
  - case-materials-warm/: 温数据存储
  - case-materials-cold/: 冷数据存储

文件命名规范:
  - 格式: {业务类型}/{年份}/{月份}/{案件ID}/{文件类型}_{时间戳}.{扩展名}
  - 示例: contracts/2024/12/1001/contract_20241201120000.pdf

优化策略:
  - 文件压缩: 减少存储空间
  - 去重处理: 相同文件只存储一份
  - 分片上传: 大文件分片处理
  - CDN加速: 提升访问速度
```

## 4. 技术选型说明

### 4.1 前端技术选型

#### 4.1.1 核心框架选择
```yaml
React 18:
  - 选择理由: 生态成熟，组件化开发，性能优秀
  - 新特性: Concurrent Features，Suspense
  - 适用场景: 复杂的B端管理系统

TypeScript:
  - 选择理由: 类型安全，提高代码质量
  - 版本: TypeScript 5.x
  - 配置: 严格模式，完整类型检查

Ant Design:
  - 选择理由: 企业级UI组件库，组件丰富
  - 版本: 5.x版本
  - 特性: 主题定制，国际化支持
```

#### 4.1.2 状态管理选择
```yaml
Zustand:
  - 选择理由: 轻量级，API简洁，TypeScript友好
  - 优势: 无样板代码，学习成本低
  - 适用: 中小型应用状态管理

替代方案:
  - Redux Toolkit: 适用于大型复杂应用
  - Recoil: Facebook出品，更适合复杂状态
```

### 4.2 后端技术选型

#### 4.2.1 开发语言选择
```yaml
Java 17 LTS:
  - 选择理由: 长期支持版本，性能提升显著
  - 新特性: Records, Pattern Matching, Text Blocks
  - 性能: 相比Java 11性能提升15-20%
  - 生态: 企业级开发生态完善

替代方案:
  - Java 21: 最新LTS版本，特性更丰富
  - Go: 高并发性能更好，但生态相对较小
  - Python: 开发效率高，但性能相对较低
```

#### 4.2.2 微服务框架选择
```yaml
Spring Cloud:
  - 选择理由: 生态完整，社区活跃，文档完善
  - 版本: 2023.x版本
  - 组件: Gateway, LoadBalancer, Config等
  - 优势: 与Spring Boot无缝集成

替代方案:
  - Dubbo: 阿里出品，性能更好，但功能相对单一
  - Service Mesh: Istio等，运维复杂度较高
```

#### 4.2.3 数据库选择
```yaml
MySQL 8.0:
  - 选择理由: 成熟稳定，性能优秀，运维成熟
  - 新特性: 窗口函数，CTE，JSON增强
  - 生态: 工具链完善，人才充足
  - 成本: 开源免费，成本可控

替代方案:
  - PostgreSQL: 功能更强大，但MySQL生态更好
  - TiDB: 分布式HTAP，适用于更大数据量
  - Oracle: 功能强大但成本高昂
```

### 4.3 中间件选型

#### 4.3.1 消息队列选择
```yaml
RocketMQ:
  - 选择理由: 阿里开源，金融级可靠性
  - 特性: 事务消息，顺序消息，延迟消息
  - 性能: 单机10万级TPS
  - 运维: 管控台完善，监控丰富

替代方案:
  - Kafka: 吞吐量更高，但可靠性相对较低
  - RabbitMQ: 功能丰富，但性能相对较低
```

#### 4.3.2 缓存选择
```yaml
Redis:
  - 选择理由: 性能优秀，数据结构丰富
  - 版本: Redis 7.0
  - 特性: 集群模式，持久化，发布订阅
  - 生态: 客户端完善，工具丰富

替代方案:
  - Memcached: 更简单，但功能单一
  - Hazelcast: Java原生，但生态相对较小
```

## 5. 安全架构设计

### 5.1 认证授权体系
```yaml
认证机制:
  - JWT令牌: 无状态认证，支持分布式
  - 令牌刷新: 双令牌机制，安全性更高
  - 单点登录: 统一身份认证

授权模型:
  - RBAC: 基于角色的访问控制
  - 资源权限: 细粒度权限控制
  - 动态权限: 支持运行时权限变更
```

### 5.2 数据安全保护
```yaml
传输安全:
  - HTTPS: 全站HTTPS加密传输
  - TLS 1.3: 使用最新TLS协议
  - 证书管理: 自动化证书更新

存储安全:
  - 数据加密: 敏感数据AES-256加密
  - 密钥管理: 密钥分离存储
  - 数据脱敏: 日志中敏感信息脱敏

访问安全:
  - 防火墙: 网络层访问控制
  - WAF: Web应用防火墙
  - IP白名单: 管理端IP限制
```

### 5.3 应用安全防护
```yaml
输入验证:
  - 参数校验: 严格的输入参数校验
  - SQL注入防护: 使用预编译语句
  - XSS防护: 输出编码和CSP策略

接口安全:
  - 接口限流: 防止恶意请求
  - 接口签名: 关键接口签名验证
  - 操作审计: 完整的操作日志

安全监控:
  - 异常检测: 异常行为自动检测
  - 安全告警: 实时安全事件告警
  - 安全扫描: 定期安全漏洞扫描
```

## 6. 监控运维体系

### 6.1 监控体系设计
```yaml
应用监控:
  - 指标监控: Prometheus收集业务指标
  - 日志监控: ELK分析应用日志
  - 链路追踪: SkyWalking追踪请求链路

基础设施监控:
  - 服务器监控: CPU、内存、磁盘、网络
  - 数据库监控: 连接数、慢查询、锁等待
  - 中间件监控: 消息队列、缓存状态

业务监控:
  - 关键指标: 案件处理量、调解成功率
  - 异常告警: 业务异常自动告警
  - 实时大屏: 业务数据实时展示
```

### 6.2 日志管理体系
```yaml
日志分类:
  - 应用日志: 业务操作日志
  - 系统日志: 系统运行日志
  - 访问日志: 用户访问日志
  - 安全日志: 安全相关日志

日志处理:
  - 收集: Filebeat收集日志
  - 传输: Logstash处理和转换
  - 存储: Elasticsearch存储和索引
  - 展示: Kibana可视化展示

日志管理:
  - 日志轮转: 定期轮转和压缩
  - 日志清理: 定期清理过期日志
  - 日志分析: 智能日志分析和告警
```

### 6.3 运维自动化
```yaml
CI/CD流程:
  - 代码提交: Git触发自动构建
  - 自动测试: 单元测试、集成测试
  - 自动部署: 蓝绿部署、滚动更新
  - 自动回滚: 发布异常自动回滚

运维自动化:
  - 容量规划: 基于监控数据自动扩容
  - 故障恢复: 自动故障检测和恢复
  - 巡检任务: 定时自动化巡检
  - 备份恢复: 自动化数据备份和恢复
```

## 7. 性能优化策略

### 7.1 前端性能优化
```yaml
加载优化:
  - 代码分割: 路由级别和组件级别代码分割
  - 懒加载: 按需加载组件和路由
  - 预加载: 关键资源预加载
  - CDN加速: 静态资源CDN分发

渲染优化:
  - 虚拟滚动: 大数据量列表虚拟滚动
  - 组件缓存: React.memo缓存组件
  - 状态优化: 合理的状态管理和更新
  - 图片优化: WebP格式，响应式图片

网络优化:
  - HTTP/2: 使用HTTP/2协议
  - 资源压缩: Gzip压缩
  - 缓存策略: 合理的缓存策略
  - 接口优化: 减少接口调用次数
```

### 7.2 后端性能优化
```yaml
数据库优化:
  - 索引优化: 合理创建和使用索引
  - 查询优化: SQL查询优化
  - 连接池: 数据库连接池优化
  - 读写分离: 主从读写分离

缓存优化:
  - 多级缓存: 本地缓存+分布式缓存
  - 缓存策略: 合理的缓存更新策略
  - 预热机制: 缓存预热避免冷启动
  - 缓存监控: 缓存命中率监控

JVM优化:
  - 垃圾回收: 选择合适的GC算法
  - 内存调优: 堆内存和非堆内存优化
  - 线程池: 合理配置线程池大小
  - 监控调优: JVM监控和性能调优
```

### 7.3 架构层面优化
```yaml
服务优化:
  - 异步处理: 使用消息队列异步处理
  - 限流降级: 接口限流和服务降级
  - 熔断机制: 防止级联故障
  - 负载均衡: 合理的负载均衡策略

存储优化:
  - 分布式存储: 数据分片和分布式存储
  - 存储分层: 热温冷数据分层存储
  - 压缩优化: 数据压缩减少存储空间
  - 访问优化: 预取和批量操作
```

---

本文档将随着系统架构的演进持续更新，请以最新版本为准。